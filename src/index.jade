doctype html
html
  head
    meta(charset='utf-8')
    meta(name='viewport', content='width=device-width, initial-scale=1, maximum-scale=1')
    title Your Build Smells

    link(rel='stylesheet', type='text/css', href='build/build.css')

  body
    article
      section(data-bespoke-state="roses").title
        h1 Your Build Smells

        address.vcard
          a.nickname.url(href='http://twitter.com/pimterry',rel="me") @pimterry
          div.org.vcard
            a.org.fn.url(href='http://softwire.com',rel="group") softw<span class="i">i</span>re
        aside
          ul
            li Tim Perry
            li @pimterry
            li Softwire
            li Automated builds - signs they're not working well, and what we can do about that

      section.softwire
        img(src="static/softwire-logo.png", style="width: 60%")
        aside
          ul
            li We build software for everybody else
            li Offices in London and Bristol
            li Lots of different projects, with a huge range of practices and levels of quality
            li We see things working badly, and have to find ways to improve them
            li We're always hiring, and we are available for hire

      section(data-bespoke-state="cogs").your-build
        h2 Your build
        aside
          ul
            li Builds
            li = tools + processes
            li How you take fresh code from your team, put it all togother, check it works, and release it to customers

      section(data-bespoke-state="cat").who-cares
        h2 Who cares? 
        aside
          ul
            li Why should we care more about this though?
          ul 
            li The pipeline that takes your code and makes it useful
            li Without, you're nothing. With, you add value.
          ul 
            li Important process, can make a big difference
            li See lots of teams where their builds are obstacles
            li Processes aimed at avoiding mistakes, rather than driving success
            li Shiny fun tools that are fun to set up that aren't very useful
            li Costs a lot of time and money and happiness
          ul
            li If we can improve this, we can deliver better software, faster, with less pain along the way

      section(data-bespoke-state="garden").gardening
        h2 
          strong Gardening
          br
          | not architecture
        aside
          ul
            li I want to be clear that I'm not proposing chasing perfection
            li Software development is gardening not architecture
            li You're trying to prune and weed things, not design a perfect glorious monument
            li Your customer does not give a damn about your tech stack. Moving to Haskell is probably a mistake
            li Don't get hung up on shiny new toys and chasing architectural beauty
            li But it is extremely important to deal with actual concrete problems
            li Anything that's genuinely slowing down you or your team

      section(data-bespoke-state="pink").smell
        h2 PAINFUL MERGES
        aside
          ul
            li Team -&gt; occasional merge conflicts
            li Seen teams where somebody spends a day a week resolving conflicts
            li Teams where whole phases on the projects are done on many branches, combined at the end
            li Even on a small scale: who has raced to push a commit?
            li All of these smell - something is bad
            li Doesn't just waste time
            li Makes refactoring nearly impossible - secret unknowable dependencies

      section(data-bespoke-state="conflict").conflict
        h2 Conflicts
        h2 are
        h2 avoidable
        h3 (usually)
        aside
          ul
            li Many of these conflicts are avoidable
            li Usually syntactic conflicts: two independent changes in the sme code
            li Both adding two fields, but on the same line
          ul  
            li Sometimes semantic conflicts: two interacting changes, but easily reconcilable once you know both are required
            li Slightly changing the return type of a method, and using the method elsewhere
          ul
            li Rarely fundamental design conflicts: you want to do X, I want conflicting Y, X+Y are mutually exclusive
            li Changing the return type of a method to two drastically different things
          ul  
            li Everything but fundamental conflicts is resolvable earlier, potentially invisibly
            li Syntactic and simple semantic conflicts would be unnoticable if we had make the changes in sequence.

      section(data-bespoke-state="isolation").isolation
        h2 Isolation
        aside
          ul
            li Happens because of isolation
            li My lLocal/branch codebase is isolated from yours
            li I keep my changes secret
            li You can't build changes that work with mine
            li Lots of resolution would be trivial with shared info
            li Renaming a field
            li Gets exponentially worse
            li Isolation can have benefits, but has a large cost

      section(data-bespoke-state="share").share-early
        h2 Share early
        aside
          ul
            li Simple solution: share your code
            li Share at the earliest point you can
            li Potentially makes conflicts disappear
            li Even unavoidable conflicts come up earlier, easier
            li Usually as soon as it doesn't break anything
            li Don't keep things local or on branches, push them sooner
            li Easier said than done.

      section(data-bespoke-state="coding").share-all
        h2 Share
        h2 tests
        h2 early
        aside
          ul
            li Tests are easy
            li If you've got a passing test written, commit it and push it now
            li Bam; nobody will secretly break your test. Potential conflict: dead. No cost.
            li If you've got a failing test written but compiling, ignore it and push it now
            li Other developers can optionally run your test
            li Changes to code it uses get found trivially by other devs
            li Changing mocks, renaming classes used, refactoring methods, etc etc

      section(data-bespoke-state="coding").share-all
        h2 Share
        h2 models
        h2 early
        aside
          ul
            li Adding or renaming fields can often be done without breaking anything
            li New method on model, new models entirely
            li Gets the code shared, highlights issues earlier

      section(data-bespoke-state="coding").share-all
        h2 Share
        h2 everything
        h2 early
        aside
          ul
            li Anywhere you can: if it doesn't break anything, share it
            li Try to do work in small chunks, without breaking things
            li Good practice for keeping focus and not yak-shaving
            li Many small standalone changes make bisection and history understanding clearer
            li Lots of small incremental changes, avoid the big bang

      section(data-bespoke-state="switch").feature-flags
        h2 Feature flags
        aside
          ul
            li Feature flags/toggles let you toggle between two implementations
            li Show new page design
            li Change algorithm used
            li Lets you branch in code
            li Changes automatically work, other developers see conflicts instantly
            li Some caution, easy to go to far
            li Last resort, when you can't finish but you have something that doesn't break anything
            li Popular as a feature themselves though: lanyrd/github/twilio/loads use for beta/alpha/AB tests

      section(data-bespoke-state="branches").branches
        h2 Branch for a reason
        aside 
          ul
            li VCS nowdays makes branching very easy
            li It's a useful powerful tool
            li It's not always the right tool
            li Lots of good reasons: developing very experimental code
            li Tracking released/development branches potentially helpful
            li Hotfixes etc
            li Main benefit of feature branches is beauty though
            li Not a good reason.
            li Even with reviews: can review while you merge; aim for lots of smaller reviews
            li Bisection is the another argument
            li If you almost always push working complete commits, doesn't matter
            li Never seen any project slowed by too few branches
            li Seen loads slowed by too many

      section(data-bespoke-state="white").conclusion
        h3.smell Painful merges
        h2 SMALL
        h2 FREQUENT
        h2 EASY
        h2 MERGES
        aside
          ul
            li Big painful merges to:
            li Smaller merges
            li Done more frequently
            li Hopefully making them all easy

      section(data-bespoke-state="pink").smell
        h2 NERVOUS PUSHES
        aside
          ul
            li So we want to push lots of small changess
            li One of the reasons people don't do that is because pushing can be scary
            li Been on teams where build after push usually broke something
            li You pushed, then sat refreshing the build monitor
          ul
            li Makes you push less
            li Distracting too: you want to be able to push and move on

      section(data-bespoke-state="explosion").just-push-it
        h2
          q 
            | Just push it
            br
            | and see
        aside
          ul
            li Anybody ever heard somebody say this?
            li Anybody ever said this?
            li This smells

      section(data-bespoke-state="explosion").run-it-again
        h2.failed BUILD FAILED
        img(src="static/loop.png")
        h2.again
          q Run it again
        aside
          ul
            li How about this?
            li If you bought a product, tried to use the thing it's made for, and it failed half the time
            li This smells

      section(data-bespoke-state="confidence").confidence
        h2 Confidence
        aside
          ul
            li Confidence = knowing pushing won't break anything
            li Lack of confidence makes other bits worse, e.g. isolation
            li Push it and see = no confidence in the state of code we're building on our machine
            li Run it again = no confidence in the state of code, even after we've already run the build once
            li Confidence lets you go fast; focus on development, no distractions, no pressure to slow down

      section.confidence-requires
        h2.accuracy Accuracy
        h2.thoroughness Thoroughness
        h2.speed Speed
        h2.simplicity Simplicity
        aside
          ul
            li Four things you want from a build to get confidence
            li Accuracy
            li Thoroughness
            li Speed
            li Simplicity
            li Mostly test focused here, but also linting tools etc, and even compilation steps
            li Let's go through them

      section.accuracy
        h2.accuracy Accuracy
        ul
          li
          li No dependencies
          li Identical environments
          li Zero tolerance
        aside
          ul
            li Your build needs to be accurate: if the code works, it should pass
            li Consistently, and reliably, with no exceptions
            li If working code fails and messes up your flow, you run the build as little as possible
            li And you ignore actually useful failures when they happen
          ul
            li Unit tests should need nothing from their environment at all
            li Integration and system level tests might, but try to limit as much as possible.
            li Any external dependencies make your code worse
            li Bundle DBs/servers/service stubs with your codebase, start them in the tests
          ul
            li Identical environments - tests should run in identical contexts all the time
            li Vagrant, Docker, etc can help with doing this for dev environment
            li Unit tests should have no dependencies, should be trivial
          ul
            li Zero tolerance for failure
            li Occasional failures are poisonous: seems cheap, but undermines quality completely
            li As soon as you have any, you start disconting failures, and being nervous about ok builds
            li Chase them disproportionately
            li Better to have no tests than intermittently failing tests (if you can't fix them)
            li PHP - 5.3.7

      section.thoroughness
        h2.thoroughness Thoroughness
        ul
          li
          li Monitor coverage <small>(a bit)</small>
          li Cover every risk <em>somewhere</em>
          li Test what might fail
        aside
          ul
            li Your build needs to be thorough: if it passes, the code works
            li Need to be confident, or you can't share your code with others
            li If build isn't thorough, you'll have to be manually thorough
            li You won't be
          ul
            li Make coverage visible in your team (monitors), and preferably your tools (NCrunch/Wallaby)
            li Coverage isn't perfect, don't chase arbitrary targets
            li But it is useful information, and overall trends and areas covered is important
          ul
            li You don't have to test every case at every level
            li If you have unit tests thoroughly checking certain behaviour, you probably don't need system tests too
            li Instead have system tests that do an overall chcek that it all works, and leave the detail to the unit tests
          ul
            li Don't test trivialities
            li If there's no way this test is ever going to fail, don't write it
            li Usually that means, test the same functionality, but further up the stack
            li Up is more complicated, so there's more to break
            li This is purely for QA; if you like TDD, TDD everything, but not for testing alone

      section.speed
        h2.speed Speed
        ul
          li
          li Quick feedback
          li <em>Watchable</em> unit tests
          li Smoke test suites
        aside
          ul
            li Tests need to be fast
            li So people can get local confidence, and fast feedback from success or failure remotely
            li Makes pushing easier, reduces context switching
          ul
            li Fast feedback is the name of the game
            li See teams with builds that run for 4 hours, and then come back and tell you every single test failed
            li That would've been good to know 4 hours ago
            li Automating the smoke test suites as your first build step can help here
            li Successful feedback is good too; lots of small steps, not a single big one, to expose success en route and give more confidence
          ul
            li Unit tests should be of a watchable length. Order of seconds
            li If they're not, then I'm not going to run them very often, and that worsens my feedback loop
            li Think about syntax errors; if they took 5 minutes too arrive, how much slower would you be?
          ul
            li Integration and system test suites are going to be slower; fight anyway
            li Smoke tests can make help: predefined suites of a few quick tests
            li That cover most of the functionality at a basic level
            li One test per page, say
            li Rapid local feedback of obvious mistakes
            li Most test runner have some kind of tagging/categorization feature

      section.simplicity
        h2.simplicity Simplicity
        ul
          li
          li One click
          li Zero setup
          li Easy debugging
        aside
          ul
            li Simple builds are easier to have confidence in
            li Easy to understand what it does, and thus to trust it
            li Easy to manage yourself, to check what the build is going to do
          ul
            li Run with one click/command
            li Very important when you have new people joining the team. Otherwise they'll do it wrong
            li Even with lots of people: I don't run builds where I have to run 10 different things
            li I pick the 'important' ones, and then I'm wrong, and the others break
            li Single click makes it really really easy for people to do, so they do it
            li Back to usability again: remove barriers to good behaviour
          ul
            li Zero setup
            li If you have setup, you have to remember it
            li When you try and do it, you'll do it wrong
            li Slightly different local environments are a recipe for absolutely zero confidence in the build
            li Again, vagrant/docker and ansible/puppet/chef/all of devops can help
          ul
            li This needs to be easily debuggable locally.
            li If it's not, when it breaks it's easier to fix the 'obvious' bug, push again and see than to really solve the problem.
            li Guide your users to the right choice

      section.conclusion
        h3.smell Nervous pushes
        h2 TESTED
        h2 QUICK
        h2 CONFIDENT
        h2 PUSHES
        aside
          ul
            li Moving from nervous pushing and uncertainty to:
            li Accurate and thoroughly tested pushes
            li With quick feedback
            li Giving us confidence in our changes, so we can go fast

      section(data-bespoke-state="pink").smell
        h2 RARE RELEASES
        aside
          ul
            li Releases are scary
            li They're the bit where everything can go wrong
            li Releasing is the most important thing you do
            li If you've got working code you're not giving to customers, you're wasting business value
            li Money/growth/customer happiness
            li Not shipping frequently, daily or more, certainly weekly, smells
            li May be business constraints too, but ensure tech is pushing the business, not business chasing tech

      section(data-bespoke-state="liftoff").releasing-is-value
        h2 Releasing<br/>creates<br/>value
        aside
          ul
            li Releases are where the rubber hits the road
            li Where your customers actually get the thing they hopefully want
            li Released code that solves their problem is exactly what 100% of your customers want
            li Unreleased code does absolutely nothing for your customers
            li The point where you release something is the one and only point where you do something useful 

      section(data-bespoke-state="liftoff").release-sooner
        h2
          | Releasing
          br
          strong SOONER
          br
          | creates
          br
          strong more
          br
          | value
        aside
          ul
            li All else being equal
            li Releasing sooner is better
            li Not just because your customers get to be happy sooner
            li Or start paying more you sooner
            li Also because you get more information sooner
            li Better feedback on what you should do next
            li More info on problems; basic functionality issues or high-level usability problems
            li This has been getting a lot of momentum as continuous deployment/delivery

      section.facebook
        img(src='static/facebook.png')
        h2
          strong 2
          br
          | releases per day
        aside
          ul
            li Facebook, for example
            li One of the most visited sites in the world
            li Obviously very high-profile if it goes down
            li They update it twice, every day
            li Wants to do more, but cautious about privacy risk

      section.github
        img(src='static/github.png')
        h2
          strong 100<small>s</small>
          br
          | releases per week
        aside
          ul
            li Github has fewer risks, so goes way further: 100s a week
            li Again, big and high profile
            li They talk a lot about it, and the speed and power it gives them

      section.netflix
        img(src='static/netflix.png')
        h2
          strong 100<small>s</small>
          br
          | releases per day
        aside
          ul
            li Netflix goes even further: 100s a day
            li Huge, enormous, and famous for their reliability and uptime
            li Netflix has ### UPTIME?
            li Microservices though, maybe that doesn't count?

      section
        h2 Why not?
        aside
          ul
            li Given all this, why does anybody not release all the time?

      section(data-bespoke-state='half-half').half-half
        div.left
          h2 RISKY
        div.right
          h2 HARD
        aside
          ul
            li It's risky - might break something!
            li It's hard - takes effort and time

      section.lower-risk
        h2 Reduce the risk
        ul.bullet
          li
          li Consistent environments
          li Automate <em>everything</em>
          li Measure <em>everything</em>
        aside
          ul
            li Kill the risk
          ul
            li Ensure your environments are the same everywhere
            li Like we talked about for accurate tests earlier: consistency gives confidence
          ul
            li Automate the hell out of this to make it happen
            li Very few excuses for this: any deployment steps easy enough to do manually should be very easy to do automatically
            li Disproportionate benefit to this kind of stuff
            li Not only your time, but improve overall quality, makes other pain more obvious
            li Quicker more-automated deployments are easier to do more often
            li So releases improve more quickly, and so does the process itself
            li Tighten the feedback loop
          ul
            li Measure everything
            li All four of the companies measured talk constantly about the different metrics they track
            li Message tends to be: publicize graphs of important stats, have everybody know them
            li Ensure people react when they see them deviating
            li Things like A/B testing and progressive rollout makes this easier, but isn't necessary

      section.make-it-easy
        h2 Make it easy
        ul.bullet
          li
          li Automate <em>everything</em>
          li One click (or fewer)
          li Everyone deploys
        aside
          ul
            li Make it easy
          ul
            li Again, automation automation automation.
            li There's theme here
            li People don't like putting in brainless effort, and they aren't good at it
            li Computers do, and are. Delegate
          ul
            li One click deployments: once everything is automated this is very easy to do
            li The only argument against is people might accidentally deploy
            li If you've got a build that won't set up broken code, and you trust your build, that's not a problem
            li Again, usability; if you want people to deploy lots, make deploying trivial
            li Design your build to guide people toward good behaviour
          ul
            li Have everybody do it, no special priviledges
            li Github for example, everybody does a deploy on their first day
            li Lots of downsides to only one person knowing how to deploy
            li Bus factor
            li Biggest is that it makes deployment process one person's responsibility
            li Time they spend improving it is selfish
            li Deploying is the only point where your team adds value
            li Everybody should be invested in that

      section.if-it-hurts
        blockquote
          p If it hurts, do it more frequently
          cite Jez Humble
        ul.bullet
          li
          li Deploy every commit
          li Deploy every night
        aside
          ul
            li Great quote from Jez Humble, author of Continuous Delivery ### FULL NAME?
            li Applies to lots of this talk, but particularly deployment here
            li If you rarely do deployments, they're huge and painful and scary
            li So they break things
            li So you deploy less.
            li You have to break the loop
          ul
            li Automatically deploy every commit
            li Not necessarily successfully at first
            li But immediately gives you a very tight feedback loop
            li Highlights issues immediately, check improvements help immediately
          ul
            li This is scary, so start with just development environments
            li Low risk, easy to experiment
            li Do need to value their quality though, treat them like production envs
          ul
            li Nightly deploys help too
            li Easy for builds to rot
            li Running the pipeline every day stops this
            li Even if not rotting, it adds extra frequency
            li Known good build, should always pass

      section.conclusion
        h3.smell Rare releases
        h2 EASY
        h2 LOW-RISK
        h2 FREQUENT
        h2 RELEASES
        aside
          ul
            li Rare occasional uncomfortable releases to:
            li Easier
            li Low-risk
            li Frequent

      section(data-bespoke-state="cumulative").cumulative
        h2 Improvements
        h3 are
        h2.cumulative CUMULATIVE
        aside
          ul
            li It's been a repeated theme throughout
            li but it's worth nothing again that a huge number of these compound nicely together
            li Removing friction both speeds up development, and makes it easier to remove more friction
            li Quicker releases both get value out the door faster, but also make it easier to do quicker releases
            li It's easy to undervalue this stuff by only looking at the immediate single time improvement
            li The extra time you make in removing friction to keep people in their flow, to build a culture where broken things are obviously bad, and bring the team together around really good development are well worth it

      section.how-to-improve
        h2.work-together Work together
        h2.focus Stay focused
        h2.measure Measure + track
        aside
          ul
            li Finally, how do you actually do all this. Three main things to power it
          ul
            li Get everybody on the team invested and directly involved.
            li Retros and discussion are good here; can't just tell people what to fix
          ul
            li Focus on one thing at a time
            li Fix one area totally, it's easier to motivate upkeep and appreciate value
            li Fix everything slightly, nobody really cares
          ul
            li Measure what you want to change
            li Releases per week, time taken to release, time since last spurious build failure
            li Useful to tell what's working
            li Also really useful for motivation for investment from people though
            li That's the really hard bit

      section(data-bespoke-state="garden").gardening
        h2 
          strong Gardening
          br
          | not architecture
        aside
          ul
            li Finally, again, we're focusing on weeding and pruning here
            li Your build is a functional tool
            li Not a beautiful toy to play with
            li Take all of this with a grain of salt
            li Above all, focus on what's hurting your team, and what helps

      section(data-bespoke-state="roses").title
        h1 Your Build Smells

        address.vcard
          a.nickname.url(href='http://twitter.com/pimterry',rel="me") @pimterry
          div.org.vcard
            a.org.fn.url(href='http://softwire.com',rel="group") Softw<span class="i">i</span>re
        aside
          ul
            li That's the lot
            li Again, I do work for Softwire, available for hire, recruiting in London/Bristol/Bucharest
            li I'm Tim Perry - pimterry on twitter - slides up later
            li Thank you

    script(src='build/build.js')
    <link href='https://fonts.googleapis.com/css?family=Josefin+Slab' rel='stylesheet' type='text/css'>
    <link href='https://fonts.googleapis.com/css?family=Bangers' rel='stylesheet' type='text/css'>
