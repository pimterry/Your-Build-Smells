<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <title>Your Build Smells</title>
    <link rel="stylesheet" type="text/css" href="build/build.css">
  </head>
  <body>
    <article>
      <section data-bespoke-state="roses" class="title">
        <h1>Your Build Smells</h1>
        <address class="vcard"><a href="http://twitter.com/pimterry" rel="me" class="nickname url">@pimterry</a>
          <div class="org vcard"><a href="http://softwire.com" rel="group" class="org fn url">softw<span class="i">i</span>re</a></div>
        </address>
        <aside>
          <ul>
            <li>Tim Perry</li>
            <li>@pimterry</li>
            <li>Softwire</li>
            <li>Automated builds - signs they're not working well, and what we can do about that</li>
          </ul>
        </aside>
      </section>
      <section class="softwire"><img src="static/softwire-logo.png" style="width: 60%">
        <aside>
          <ul>
            <li>We build software for everybody else</li>
            <li>Offices in London and Bristol</li>
            <li>Lots of different projects, with a huge range of practices and levels of quality</li>
            <li>We see things working badly, and have to find ways to improve them</li>
            <li>We're always hiring, and we are available for hire</li>
          </ul>
        </aside>
      </section>
      <section data-bespoke-state="cogs" class="your-build">
        <h2>Your build</h2>
        <aside>
          <ul>
            <li>Builds</li>
            <li>= tools + processes</li>
            <li>How you take fresh code from your team, put it all togother, check it works, and release it to customers</li>
          </ul>
        </aside>
      </section>
      <section data-bespoke-state="cat" class="who-cares">
        <h2>Who cares? </h2>
        <aside>
          <ul>
            <li>Why should we care more about this though?</li>
          </ul>
          <ul>
            <li>The pipeline that takes your code and makes it useful</li>
            <li>Without, you're nothing. With, you add value.</li>
          </ul>
          <ul>
            <li>Important process, can make a big difference</li>
            <li>See lots of teams where their builds are obstacles</li>
            <li>Processes aimed at avoiding mistakes, rather than driving success</li>
            <li>Shiny fun tools that are fun to set up that aren't very useful</li>
            <li>Costs a lot of time and money and happiness</li>
          </ul>
          <ul>
            <li>If we can improve this, we can deliver better software, faster, with less pain along the way</li>
          </ul>
        </aside>
      </section>
      <section data-bespoke-state="garden" class="gardening">
        <h2><strong>Gardening</strong><br>not architecture</h2>
        <aside>
          <ul>
            <li>I want to be clear that I'm not proposing chasing perfection</li>
            <li>Software development is gardening not architecture</li>
            <li>You're trying to prune and weed things, not design a perfect glorious monument</li>
            <li>Your customer does not give a damn about your tech stack. Moving to Haskell is probably a mistake</li>
            <li>Don't get hung up on shiny new toys and chasing architectural beauty</li>
            <li>But it is extremely important to deal with actual concrete problems</li>
            <li>Anything that's genuinely slowing down you or your team</li>
          </ul>
        </aside>
      </section>
      <section data-bespoke-state="pink" class="smell">
        <h2>PAINFUL MERGES</h2>
        <aside>
          <ul>
            <li>Team -&gt; occasional merge conflicts</li>
            <li>Seen teams where somebody spends a day a week resolving conflicts</li>
            <li>Teams where whole phases on the projects are done on many branches, combined at the end</li>
            <li>Even on a small scale: who has raced to push a commit?</li>
            <li>All of these smell - something is bad</li>
            <li>Doesn't just waste time</li>
            <li>Makes refactoring nearly impossible - secret unknowable dependencies</li>
          </ul>
        </aside>
      </section>
      <section data-bespoke-state="conflict" class="conflict">
        <h2>Conflicts</h2>
        <h2>are</h2>
        <h2>avoidable</h2>
        <h3>(usually)</h3>
        <aside>
          <ul>
            <li>Many of these conflicts are avoidable</li>
            <li>Usually syntactic conflicts: two independent changes in the sme code</li>
            <li>Both adding two fields, but on the same line</li>
          </ul>
          <ul> 
            <li>Sometimes semantic conflicts: two interacting changes, but easily reconcilable once you know both are required</li>
            <li>Slightly changing the return type of a method, and using the method elsewhere</li>
          </ul>
          <ul>
            <li>Rarely fundamental design conflicts: you want to do X, I want conflicting Y, X+Y are mutually exclusive</li>
            <li>Changing the return type of a method to two drastically different things</li>
          </ul>
          <ul> 
            <li>Everything but fundamental conflicts is resolvable earlier, potentially invisibly</li>
            <li>Syntactic and simple semantic conflicts would be unnoticable if we had make the changes in sequence.</li>
          </ul>
        </aside>
      </section>
      <section data-bespoke-state="isolation" class="isolation">
        <h2>Isolation</h2>
        <aside>
          <ul>
            <li>Happens because of isolation</li>
            <li>My lLocal/branch codebase is isolated from yours</li>
            <li>I keep my changes secret</li>
            <li>You can't build changes that work with mine</li>
            <li>Lots of resolution would be trivial with shared info</li>
            <li>Renaming a field</li>
            <li>Gets exponentially worse</li>
            <li>Isolation can have benefits, but has a large cost</li>
          </ul>
        </aside>
      </section>
      <section data-bespoke-state="share" class="share-early">
        <h2>Share early</h2>
        <aside>
          <ul>
            <li>Simple solution: share your code</li>
            <li>Share at the earliest point you can</li>
            <li>Potentially makes conflicts disappear</li>
            <li>Even unavoidable conflicts come up earlier, easier</li>
            <li>Usually as soon as it doesn't break anything</li>
            <li>Don't keep things local or on branches, push them sooner</li>
            <li>Easier said than done.</li>
          </ul>
        </aside>
      </section>
      <section data-bespoke-state="coding" class="share-all">
        <h2>Share</h2>
        <h2>tests</h2>
        <h2>early</h2>
        <aside>
          <ul>
            <li>Tests are easy</li>
            <li>If you've got a passing test written, commit it and push it now</li>
            <li>Bam; nobody will secretly break your test. Potential conflict: dead. No cost.</li>
            <li>If you've got a failing test written but compiling, ignore it and push it now</li>
            <li>Other developers can optionally run your test</li>
            <li>Changes to code it uses get found trivially by other devs</li>
            <li>Changing mocks, renaming classes used, refactoring methods, etc etc</li>
          </ul>
        </aside>
      </section>
      <section data-bespoke-state="coding" class="share-all">
        <h2>Share</h2>
        <h2>models</h2>
        <h2>early</h2>
        <aside>
          <ul>
            <li>Adding or renaming fields can often be done without breaking anything</li>
            <li>New method on model, new models entirely</li>
            <li>Gets the code shared, highlights issues earlier</li>
          </ul>
        </aside>
      </section>
      <section data-bespoke-state="coding" class="share-all">
        <h2>Share</h2>
        <h2>everything</h2>
        <h2>early</h2>
        <aside>
          <ul>
            <li>Anywhere you can: if it doesn't break anything, share it</li>
            <li>Try to do work in small chunks, without breaking things</li>
            <li>Good practice for keeping focus and not yak-shaving</li>
            <li>Many small standalone changes make bisection and history understanding clearer</li>
            <li>Lots of small incremental changes, avoid the big bang</li>
          </ul>
        </aside>
      </section>
      <section data-bespoke-state="switch" class="feature-flags">
        <h2>Feature flags</h2>
        <aside>
          <ul>
            <li>Feature flags/toggles let you toggle between two implementations</li>
            <li>Show new page design</li>
            <li>Change algorithm used</li>
            <li>Lets you branch in code</li>
            <li>Changes automatically work, other developers see conflicts instantly</li>
            <li>Some caution, easy to go to far</li>
            <li>Last resort, when you can't finish but you have something that doesn't break anything</li>
            <li>Popular as a feature themselves though: lanyrd/github/twilio/loads use for beta/alpha/AB tests</li>
          </ul>
        </aside>
      </section>
      <section data-bespoke-state="branches" class="branches">
        <h2>Branch for a reason</h2>
        <aside>
          <ul>
            <li>VCS nowdays makes branching very easy</li>
            <li>It's a useful powerful tool</li>
            <li>It's not always the right tool</li>
            <li>Lots of good reasons: developing very experimental code</li>
            <li>Tracking released/development branches potentially helpful</li>
            <li>Hotfixes etc</li>
            <li>Main benefit of feature branches is beauty though</li>
            <li>Not a good reason.</li>
            <li>Even with reviews: can review while you merge; aim for lots of smaller reviews</li>
            <li>Bisection is the another argument</li>
            <li>If you almost always push working complete commits, doesn't matter</li>
            <li>Never seen any project slowed by too few branches</li>
            <li>Seen loads slowed by too many</li>
          </ul>
        </aside>
      </section>
      <section data-bespoke-state="white" class="conclusion">
        <h3 class="smell">Painful merges</h3>
        <h2>SMALL</h2>
        <h2>FREQUENT</h2>
        <h2>EASY</h2>
        <h2>MERGES</h2>
        <aside>
          <ul>
            <li>Big painful merges to:</li>
            <li>Smaller merges</li>
            <li>Done more frequently</li>
            <li>Hopefully making them all easy</li>
          </ul>
        </aside>
      </section>
      <section data-bespoke-state="pink" class="smell">
        <h2>NERVOUS PUSHES</h2>
        <aside>
          <ul>
            <li>So we want to push lots of small changess</li>
            <li>One of the reasons people don't do that is because pushing can be scary</li>
            <li>Been on teams where build after push usually broke something</li>
            <li>You pushed, then sat refreshing the build monitor</li>
          </ul>
          <ul>
            <li>Makes you push less</li>
            <li>Distracting too: you want to be able to push and move on</li>
          </ul>
        </aside>
      </section>
      <section data-bespoke-state="explosion" class="just-push-it">
        <h2>
          <q>Just push it<br>and see</q>
        </h2>
        <aside>
          <ul>
            <li>Anybody ever heard somebody say this?</li>
            <li>Anybody ever said this?</li>
            <li>This smells</li>
          </ul>
        </aside>
      </section>
      <section data-bespoke-state="explosion" class="run-it-again">
        <h2 class="failed">BUILD FAILED</h2><img src="static/loop.png">
        <h2 class="again">
          <q>Run it again</q>
        </h2>
        <aside>
          <ul>
            <li>How about this?</li>
            <li>If you bought a product, tried to use the thing it's made for, and it failed half the time</li>
            <li>This smells</li>
          </ul>
        </aside>
      </section>
      <section data-bespoke-state="confidence" class="confidence">
        <h2>Confidence</h2>
        <aside>
          <ul>
            <li>Confidence = knowing pushing won't break anything</li>
            <li>Lack of confidence makes other bits worse, e.g. isolation</li>
            <li>Push it and see = no confidence in the state of code we're building on our machine</li>
            <li>Run it again = no confidence in the state of code, even after we've already run the build once</li>
            <li>Confidence lets you go fast; focus on development, no distractions, no pressure to slow down</li>
          </ul>
        </aside>
      </section>
      <section class="confidence-requires">
        <h2 class="accuracy">Accuracy</h2>
        <h2 class="thoroughness">Thoroughness</h2>
        <h2 class="speed">Speed</h2>
        <h2 class="simplicity">Simplicity</h2>
        <aside>
          <ul>
            <li>Four things you want from a build to get confidence</li>
            <li>Accuracy</li>
            <li>Thoroughness</li>
            <li>Speed</li>
            <li>Simplicity</li>
            <li>Mostly test focused here, but also linting tools etc, and even compilation steps</li>
            <li>Let's go through them</li>
          </ul>
        </aside>
      </section>
      <section class="accuracy">
        <h2 class="accuracy">Accuracy</h2>
        <ul>
          <li></li>
          <li>No dependencies</li>
          <li>Identical environments</li>
          <li>Zero tolerance</li>
        </ul>
        <aside>
          <ul>
            <li>Your build needs to be accurate: if the code works, it should pass</li>
            <li>Consistently, and reliably, with no exceptions</li>
            <li>If working code fails and messes up your flow, you run the build as little as possible</li>
            <li>And you ignore actually useful failures when they happen</li>
          </ul>
          <ul>
            <li>Unit tests should need nothing from their environment at all</li>
            <li>Integration and system level tests might, but try to limit as much as possible.</li>
            <li>Any external dependencies make your code worse</li>
            <li>Bundle DBs/servers/service stubs with your codebase, start them in the tests</li>
          </ul>
          <ul>
            <li>Identical environments - tests should run in identical contexts all the time</li>
            <li>Vagrant, Docker, etc can help with doing this for dev environment</li>
            <li>Unit tests should have no dependencies, should be trivial</li>
          </ul>
          <ul>
            <li>Zero tolerance for failure</li>
            <li>Occasional failures are poisonous: seems cheap, but undermines quality completely</li>
            <li>As soon as you have any, you start disconting failures, and being nervous about ok builds</li>
            <li>Chase them disproportionately</li>
            <li>Better to have no tests than intermittently failing tests (if you can't fix them)</li>
            <li>PHP - 5.3.7</li>
          </ul>
        </aside>
      </section>
      <section class="thoroughness">
        <h2 class="thoroughness">Thoroughness</h2>
        <ul>
          <li></li>
          <li>Monitor coverage <small>(a bit)</small></li>
          <li>Cover every risk <em>somewhere</em></li>
          <li>Test what might fail</li>
        </ul>
        <aside>
          <ul>
            <li>Your build needs to be thorough: if it passes, the code works</li>
            <li>Need to be confident, or you can't share your code with others</li>
            <li>If build isn't thorough, you'll have to be manually thorough</li>
            <li>You won't be</li>
          </ul>
          <ul>
            <li>Make coverage visible in your team (monitors), and preferably your tools (NCrunch/Wallaby)</li>
            <li>Coverage isn't perfect, don't chase arbitrary targets</li>
            <li>But it is useful information, and overall trends and areas covered is important</li>
          </ul>
          <ul>
            <li>You don't have to test every case at every level</li>
            <li>If you have unit tests thoroughly checking certain behaviour, you probably don't need system tests too</li>
            <li>Instead have system tests that do an overall chcek that it all works, and leave the detail to the unit tests</li>
          </ul>
          <ul>
            <li>Don't test trivialities</li>
            <li>If there's no way this test is ever going to fail, don't write it</li>
            <li>Usually that means, test the same functionality, but further up the stack</li>
            <li>Up is more complicated, so there's more to break</li>
            <li>This is purely for QA; if you like TDD, TDD everything, but not for testing alone</li>
          </ul>
        </aside>
      </section>
      <section class="speed">
        <h2 class="speed">Speed</h2>
        <ul>
          <li></li>
          <li>Quick feedback</li>
          <li><em>Watchable</em> unit tests</li>
          <li>Smoke test suites</li>
        </ul>
        <aside>
          <ul>
            <li>Tests need to be fast</li>
            <li>So people can get local confidence, and fast feedback from success or failure remotely</li>
            <li>Makes pushing easier, reduces context switching</li>
          </ul>
          <ul>
            <li>Fast feedback is the name of the game</li>
            <li>See teams with builds that run for 4 hours, and then come back and tell you every single test failed</li>
            <li>That would've been good to know 4 hours ago</li>
            <li>Automating the smoke test suites as your first build step can help here</li>
            <li>Successful feedback is good too; lots of small steps, not a single big one, to expose success en route and give more confidence</li>
          </ul>
          <ul>
            <li>Unit tests should be of a watchable length. Order of seconds</li>
            <li>If they're not, then I'm not going to run them very often, and that worsens my feedback loop</li>
            <li>Think about syntax errors; if they took 5 minutes too arrive, how much slower would you be?</li>
          </ul>
          <ul>
            <li>Integration and system test suites are going to be slower; fight anyway</li>
            <li>Smoke tests can make help: predefined suites of a few quick tests</li>
            <li>That cover most of the functionality at a basic level</li>
            <li>One test per page, say</li>
            <li>Rapid local feedback of obvious mistakes</li>
            <li>Most test runner have some kind of tagging/categorization feature</li>
          </ul>
        </aside>
      </section>
      <section class="simplicity">
        <h2 class="simplicity">Simplicity</h2>
        <ul>
          <li></li>
          <li>One click</li>
          <li>Zero setup</li>
          <li>Easy debugging</li>
        </ul>
        <aside>
          <ul>
            <li>Simple builds are easier to have confidence in</li>
            <li>Easy to understand what it does, and thus to trust it</li>
            <li>Easy to manage yourself, to check what the build is going to do</li>
          </ul>
          <ul>
            <li>Run with one click/command</li>
            <li>Very important when you have new people joining the team. Otherwise they'll do it wrong</li>
            <li>Even with lots of people: I don't run builds where I have to run 10 different things</li>
            <li>I pick the 'important' ones, and then I'm wrong, and the others break</li>
            <li>Single click makes it really really easy for people to do, so they do it</li>
            <li>Back to usability again: remove barriers to good behaviour</li>
          </ul>
          <ul>
            <li>Zero setup</li>
            <li>If you have setup, you have to remember it</li>
            <li>When you try and do it, you'll do it wrong</li>
            <li>Slightly different local environments are a recipe for absolutely zero confidence in the build</li>
            <li>Again, vagrant/docker and ansible/puppet/chef/all of devops can help</li>
          </ul>
          <ul>
            <li>This needs to be easily debuggable locally.</li>
            <li>If it's not, when it breaks it's easier to fix the 'obvious' bug, push again and see than to really solve the problem.</li>
            <li>Guide your users to the right choice</li>
          </ul>
        </aside>
      </section>
      <section class="conclusion">
        <h3 class="smell">Nervous pushes</h3>
        <h2>TESTED</h2>
        <h2>QUICK</h2>
        <h2>CONFIDENT</h2>
        <h2>PUSHES</h2>
        <aside>
          <ul>
            <li>Moving from nervous pushing and uncertainty to:</li>
            <li>Accurate and thoroughly tested pushes</li>
            <li>With quick feedback</li>
            <li>Giving us confidence in our changes, so we can go fast</li>
          </ul>
        </aside>
      </section>
      <section data-bespoke-state="pink" class="smell">
        <h2>RARE RELEASES</h2>
        <aside>
          <ul>
            <li>Releases are scary</li>
            <li>They're the bit where everything can go wrong</li>
            <li>Releasing is the most important thing you do</li>
            <li>If you've got working code you're not giving to customers, you're wasting business value</li>
            <li>Money/growth/customer happiness</li>
            <li>Not shipping frequently, daily or more, certainly weekly, smells</li>
            <li>May be business constraints too, but ensure tech is pushing the business, not business chasing tech</li>
          </ul>
        </aside>
      </section>
      <section data-bespoke-state="liftoff" class="releasing-is-value">
        <h2>Releasing<br/>creates<br/>value</h2>
        <aside>
          <ul>
            <li>Releases are where the rubber hits the road</li>
            <li>Where your customers actually get the thing they hopefully want</li>
            <li>Released code that solves their problem is exactly what 100% of your customers want</li>
            <li>Unreleased code does absolutely nothing for your customers</li>
            <li>The point where you release something is the one and only point where you do something useful </li>
          </ul>
        </aside>
      </section>
      <section data-bespoke-state="liftoff" class="release-sooner">
        <h2>Releasing<br><strong>SOONER</strong><br>creates<br><strong>more</strong><br>value</h2>
        <aside>
          <ul>
            <li>All else being equal</li>
            <li>Releasing sooner is better</li>
            <li>Not just because your customers get to be happy sooner</li>
            <li>Or start paying more you sooner</li>
            <li>Also because you get more information sooner</li>
            <li>Better feedback on what you should do next</li>
            <li>More info on problems; basic functionality issues or high-level usability problems</li>
            <li>This has been getting a lot of momentum as continuous deployment/delivery</li>
          </ul>
        </aside>
      </section>
      <section class="facebook"><img src="static/facebook.png">
        <h2><strong>2</strong><br>releases per day</h2>
        <aside>
          <ul>
            <li>Facebook, for example</li>
            <li>One of the most visited sites in the world</li>
            <li>Obviously very high-profile if it goes down</li>
            <li>They update it twice, every day</li>
            <li>Wants to do more, but cautious about privacy risk</li>
          </ul>
        </aside>
      </section>
      <section class="github"><img src="static/github.png">
        <h2><strong>100<small>s</small></strong><br>releases per week</h2>
        <aside>
          <ul>
            <li>Github has fewer risks, so goes way further: 100s a week</li>
            <li>Again, big and high profile</li>
            <li>They talk a lot about it, and the speed and power it gives them</li>
          </ul>
        </aside>
      </section>
      <section class="netflix"><img src="static/netflix.png">
        <h2><strong>100<small>s</small></strong><br>releases per day</h2>
        <aside>
          <ul>
            <li>Netflix goes even further: 100s a day</li>
            <li>Huge, enormous, and famous for their reliability and uptime</li>
            <li>Netflix has ### UPTIME?</li>
            <li>Microservices though, maybe that doesn't count?</li>
          </ul>
        </aside>
      </section>
      <section>
        <h2>Why not?</h2>
        <aside>
          <ul>
            <li>Given all this, why does anybody not release all the time?</li>
          </ul>
        </aside>
      </section>
      <section data-bespoke-state="half-half" class="half-half">
        <div class="left">
          <h2>RISKY</h2>
        </div>
        <div class="right">
          <h2>HARD</h2>
        </div>
        <aside>
          <ul>
            <li>It's risky - might break something!</li>
            <li>It's hard - takes effort and time</li>
          </ul>
        </aside>
      </section>
      <section class="lower-risk">
        <h2>Reduce the risk</h2>
        <ul class="bullet">
          <li></li>
          <li>Consistent environments</li>
          <li>Automate <em>everything</em></li>
          <li>Measure <em>everything</em></li>
        </ul>
        <aside>
          <ul>
            <li>Kill the risk</li>
          </ul>
          <ul>
            <li>Ensure your environments are the same everywhere</li>
            <li>Like we talked about for accurate tests earlier: consistency gives confidence</li>
          </ul>
          <ul>
            <li>Automate the hell out of this to make it happen</li>
            <li>Very few excuses for this: any deployment steps easy enough to do manually should be very easy to do automatically</li>
            <li>Disproportionate benefit to this kind of stuff</li>
            <li>Not only your time, but improve overall quality, makes other pain more obvious</li>
            <li>Quicker more-automated deployments are easier to do more often</li>
            <li>So releases improve more quickly, and so does the process itself</li>
            <li>Tighten the feedback loop</li>
          </ul>
          <ul>
            <li>Measure everything</li>
            <li>All four of the companies measured talk constantly about the different metrics they track</li>
            <li>Message tends to be: publicize graphs of important stats, have everybody know them</li>
            <li>Ensure people react when they see them deviating</li>
            <li>Things like A/B testing and progressive rollout makes this easier, but isn't necessary</li>
          </ul>
        </aside>
      </section>
      <section class="make-it-easy">
        <h2>Make it easy</h2>
        <ul class="bullet">
          <li></li>
          <li>Automate <em>everything</em></li>
          <li>One click (or fewer)</li>
          <li>Everyone deploys</li>
        </ul>
        <aside>
          <ul>
            <li>Make it easy</li>
          </ul>
          <ul>
            <li>Again, automation automation automation.</li>
            <li>There's theme here</li>
            <li>People don't like putting in brainless effort, and they aren't good at it</li>
            <li>Computers do, and are. Delegate</li>
          </ul>
          <ul>
            <li>One click deployments: once everything is automated this is very easy to do</li>
            <li>The only argument against is people might accidentally deploy</li>
            <li>If you've got a build that won't set up broken code, and you trust your build, that's not a problem</li>
            <li>Again, usability; if you want people to deploy lots, make deploying trivial</li>
            <li>Design your build to guide people toward good behaviour</li>
          </ul>
          <ul>
            <li>Have everybody do it, no special priviledges</li>
            <li>Github for example, everybody does a deploy on their first day</li>
            <li>Lots of downsides to only one person knowing how to deploy</li>
            <li>Bus factor</li>
            <li>Biggest is that it makes deployment process one person's responsibility</li>
            <li>Time they spend improving it is selfish</li>
            <li>Deploying is the only point where your team adds value</li>
            <li>Everybody should be invested in that</li>
          </ul>
        </aside>
      </section>
      <section class="if-it-hurts">
        <blockquote>
          <p>If it hurts, do it more frequently</p>
          <cite>Jez Humble</cite>
        </blockquote>
        <ul class="bullet">
          <li></li>
          <li>Deploy every commit</li>
          <li>Deploy every night</li>
        </ul>
        <aside>
          <ul>
            <li>Great quote from Jez Humble, author of Continuous Delivery ### FULL NAME?</li>
            <li>Applies to lots of this talk, but particularly deployment here</li>
            <li>If you rarely do deployments, they're huge and painful and scary</li>
            <li>So they break things</li>
            <li>So you deploy less.</li>
            <li>You have to break the loop</li>
          </ul>
          <ul>
            <li>Automatically deploy every commit</li>
            <li>Not necessarily successfully at first</li>
            <li>But immediately gives you a very tight feedback loop</li>
            <li>Highlights issues immediately, check improvements help immediately</li>
          </ul>
          <ul>
            <li>This is scary, so start with just development environments</li>
            <li>Low risk, easy to experiment</li>
            <li>Do need to value their quality though, treat them like production envs</li>
          </ul>
          <ul>
            <li>Nightly deploys help too</li>
            <li>Easy for builds to rot</li>
            <li>Running the pipeline every day stops this</li>
            <li>Even if not rotting, it adds extra frequency</li>
            <li>Known good build, should always pass</li>
          </ul>
        </aside>
      </section>
      <section class="conclusion">
        <h3 class="smell">Rare releases</h3>
        <h2>EASY</h2>
        <h2>LOW-RISK</h2>
        <h2>FREQUENT</h2>
        <h2>RELEASES</h2>
        <aside>
          <ul>
            <li>Rare occasional uncomfortable releases to:</li>
            <li>Easier</li>
            <li>Low-risk</li>
            <li>Frequent</li>
          </ul>
        </aside>
      </section>
      <section data-bespoke-state="cumulative" class="cumulative">
        <h2>Improvements</h2>
        <h3>are</h3>
        <h2 class="cumulative">CUMULATIVE</h2>
        <aside>
          <ul>
            <li>It's been a repeated theme throughout</li>
            <li>but it's worth nothing again that a huge number of these compound nicely together</li>
            <li>Removing friction both speeds up development, and makes it easier to remove more friction</li>
            <li>Quicker releases both get value out the door faster, but also make it easier to do quicker releases</li>
            <li>It's easy to undervalue this stuff by only looking at the immediate single time improvement</li>
            <li>The extra time you make in removing friction to keep people in their flow, to build a culture where broken things are obviously bad, and bring the team together around really good development are well worth it</li>
          </ul>
        </aside>
      </section>
      <section data-bespoke-state="garden" class="gardening">
        <h2><strong>Gardening</strong><br>not architecture</h2>
        <aside>
          <ul>
            <li>Finally, again, we're focusing on weeding and pruning here</li>
            <li>Your build is a functional tool</li>
            <li>Not a beautiful toy to play with</li>
            <li>Take all of this with a grain of salt</li>
            <li>Above all, focus on what's hurting your team, and what helps</li>
          </ul>
        </aside>
      </section>
      <section data-bespoke-state="roses" class="title">
        <h1>Your Build Smells</h1>
        <address class="vcard"><a href="http://twitter.com/pimterry" rel="me" class="nickname url">@pimterry</a>
          <div class="org vcard"><a href="http://softwire.com" rel="group" class="org fn url">Softw<span class="i">i</span>re</a></div>
        </address>
        <aside>
          <ul>
            <li>That's the lot</li>
            <li>Again, I do work for Softwire, available for hire, recruiting in London/Bristol/Bucharest</li>
            <li>I'm Tim Perry - pimterry on twitter - slides up later</li>
            <li>Thank you</li>
          </ul>
        </aside>
      </section>
    </article>
    <script src="build/build.js"></script><link href='https://fonts.googleapis.com/css?family=Josefin+Slab' rel='stylesheet' type='text/css'>
    <link href='https://fonts.googleapis.com/css?family=Bangers' rel='stylesheet' type='text/css'>
  </body>
</html>